# 점프
"""
# 문제
여행을 떠난 세준이는 지도를 하나 구하였다. 
이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 
한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 
각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.
현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 
제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 

그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 
위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.

지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 
제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.

# 입력
첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 
이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 
각 지점의 높이가 빈 칸을 사이에 두고 주어진다. 
M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.



# 출력
첫째 줄에 이동 가능한 경로의 수 H를 출력한다.
모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.
"""

import sys
N, M = map(int, sys.stdin.readline().split())

# 범위 체크 생략 위한 0 패딩(상하좌우 모두)
arr = [[0]*(M+2)] + [[0] + list(map(int, sys.stdin.readline().split())) + [0] for _ in range(N)] + [[0]*(M+2)]
dp = [[-1]*(M+2) for _ in range(N+2)] # dp는 방문안한 경우 -1로 설정(경로 0개 -> 0, 1개 -> 1 등 표기 위해)

dp[1][1] = 1        # 시작점 지정

# 네 방향 설정
d = ((-1, 0), (1, 0), (0, -1), (0, 1))

def dfs(i, j):
    if dp[i][j] == -1: # 만약 계산이 안된 좌표일 경우
        # 조건: 네방향, 낮은 곳으로 방문 -> 경로수 누적
        dp[i][j] = 0    # 계산했다고 표기 및 이후 누적 시행
        
        for di, dj in d:    # 네 방향 탐색
            ni, nj = i + di, j + dj 

            if arr[ni][nj] > arr[i][j]: # 내리막인 경우에만(이동 좌표의 값이 더 작은 경우에만)
                dp[i][j] += dfs[ni][nj] # 네 방향 경로 수 누적, 재귀 호출하여 -1인 것 반복
    
    return dp[i][j]
print(dfs(N, M))



def dfs(ci,cj):
    if dp[ci][cj]==-1:                  # 아직 계산 안 된 경우(첫 방문)는 계산후 저장
        # 네 방향(더 높은곳으로부터 낮은곳방문시 경로수 누적
        dp[ci][cj]=0
        for di,dj in ((-1,0),(1,0),(0,-1),(0,1)):
            pi,pj = ci+di, cj+dj        # 이전좌표 계산
            if arr[pi][pj]>arr[ci][cj]: # 내리막길인 경우
                dp[ci][cj]+=dfs(pi,pj)  # 조건에 맞는 네 방향 경로수 누적
    return dp[ci][cj]

N, M = map(int, input().split())
# 범위체크를 생략하기 위해서 0으로 둘러쌈
arr = [[0]*(M+2)]+[[0]+list(map(int, input().split()))+[0] for _ in range(N)]+[[0]*(M+2)]

# dp 테이블 생성 및 초기값 설정
dp = [[-1]*(M+2) for _ in range(N+2)]

print(dfs(N, M))

