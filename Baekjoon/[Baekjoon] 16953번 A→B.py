# 16953번 A→B
## A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값 출력
## 만들 수 없는 경우에는 -1을 출력

A,B = map(int,input().split())
min_num = 1

# A1. A 기준 모든 경우의 수 탐색
## -> 간단하게 풀 아이디어가 필요함.
"""
A1에서 A2로 갈 때 *2 or +1로 파생(2개)
A2(2개)에서 A3으로 갈 때 *2 or +1로 파생(4개)
-> 너무 많은 연산 필요(2^n, n=step)

A=B일 때까지, A>B가 될 경우 해당 파생 분기는 제거
(단, 모든 파생 경우의 수에서 A>B가 될 경우 print(-1))

"""

# A2. B에서 A로 만들어주기
"""
1) 만약 끝자리가 1일 경우 -> 2가 곱해져서 1이 나올 수 없기 때문에 A에서 B로의 경우는 +1인 경우로 한정됨.
2) 만약 2로 나눠질 경우   -> +1로 만들어 질 수 없는 B 값이기 때문에 무조건 A는 2를 곱하여 진행되는 경우로 한정됨. 

따라서, 문제를 거꾸로 접근하여 B에서 A를 만드는 한정된 경우를 고려,
조건1) 1로 끝나는 경우 끝자리 1을 없애고
조건2) 2로 나뉘는 경우 나누기 2를 하고
조건3) 만약, 두 경우를 탐색한 결과 A와 일치할 수 없다면 -1 출력
""" 

while (A != B):
    min_num += 1
    temp = B
    
    if B % 10 == 1:
        B//=10
    elif B % 2 == 0:
        B//=2
        
    if B == temp:
        min_num = -1
        break

print(min_num)
